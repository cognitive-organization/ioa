name: CEO Cockpit â€” Daily Digest

on:
  schedule:
    # 06:00 BRT = 09:00 UTC, weekdays only
    - cron: '0 9 * * 1-5'
  workflow_dispatch:

permissions:
  issues: write
  contents: read
  pull-requests: read

jobs:
  daily-digest:
    runs-on: ubuntu-latest
    steps:
      - name: Generate CEO Cockpit Report
        id: report
        uses: actions/github-script@v8
        with:
          github-token: ${{ secrets.GH_PAT }}
          script: |
            const now = new Date();
            const yesterday = new Date(now.getTime() - 24 * 60 * 60 * 1000);
            const since = yesterday.toISOString();

            const brtDate = now.toLocaleDateString('pt-BR', {
              timeZone: 'America/Sao_Paulo',
              weekday: 'long',
              year: 'numeric',
              month: 'long',
              day: 'numeric'
            });

            const owner = context.repo.owner;
            const repo = context.repo.repo;

            // === Project Board Data via GraphQL ===
            const PROJECT_NUMBER = 1;
            const projectOwner = 'cognitive-organization';
            let projectItems = [];
            try {
              const result = await github.graphql(`
                query($owner: String!, $number: Int!) {
                  organization(login: $owner) {
                    projectV2(number: $number) {
                      items(first: 100) {
                        nodes {
                          fieldValues(first: 20) {
                            nodes {
                              ... on ProjectV2ItemFieldSingleSelectValue {
                                name
                                field { ... on ProjectV2SingleSelectField { name } }
                              }
                              ... on ProjectV2ItemFieldTextValue {
                                text
                                field { ... on ProjectV2FieldCommon { name } }
                              }
                            }
                          }
                          content {
                            ... on Issue {
                              number
                              title
                              url
                              state
                              labels(first: 10) {
                                nodes { name }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              `, { owner: projectOwner, number: PROJECT_NUMBER });

              projectItems = result.organization.projectV2.items.nodes
                .filter(item => item.content && item.content.number)
                .map(item => {
                  const fields = {};
                  for (const fv of item.fieldValues.nodes) {
                    if (fv.field && fv.field.name) {
                      fields[fv.field.name] = fv.name || fv.text || '';
                    }
                  }
                  return {
                    number: item.content.number,
                    title: item.content.title,
                    url: item.content.url,
                    state: item.content.state,
                    labels: item.content.labels.nodes.map(l => l.name),
                    ...fields
                  };
                });
            } catch (e) {
              console.log(`Project query failed: ${e.message}`);
            }

            // === Counts by Status ===
            const statusCounts = {};
            const agentCounts = {};
            const priorityCounts = {};
            const blockedItems = [];
            const tonightItems = [];
            const runningItems = [];
            const reviewItems = [];

            for (const item of projectItems) {
              const status = item.Status || 'Unknown';
              const agent = item.Agent || 'â€”';
              const priority = item.Priority || 'â€”';

              statusCounts[status] = (statusCounts[status] || 0) + 1;
              agentCounts[agent] = (agentCounts[agent] || 0) + 1;
              priorityCounts[priority] = (priorityCounts[priority] || 0) + 1;

              if (status.includes('Blocked')) blockedItems.push(item);
              if (status.includes('Tonight')) tonightItems.push(item);
              if (status.includes('Running')) runningItems.push(item);
              if (status.includes('Review')) reviewItems.push(item);
            }

            // === Commits in last 24h ===
            let commits = [];
            try {
              const { data } = await github.rest.repos.listCommits({
                owner, repo, since, per_page: 20
              });
              commits = data;
            } catch (e) {
              console.log('No commits found');
            }

            // === PRs merged in last 24h ===
            let mergedPRs = [];
            try {
              const { data } = await github.rest.pulls.list({
                owner, repo, state: 'closed', sort: 'updated', direction: 'desc', per_page: 20
              });
              mergedPRs = data.filter(pr =>
                pr.merged_at && new Date(pr.merged_at) > yesterday
              );
            } catch (e) {
              console.log('No merged PRs found');
            }

            // === Issues opened/closed in last 24h ===
            let openedIssues = [];
            let closedIssues = [];
            try {
              const { data } = await github.rest.issues.listForRepo({
                owner, repo, state: 'all', since, sort: 'updated', direction: 'desc', per_page: 50
              });
              const issues = data.filter(i => !i.pull_request);
              openedIssues = issues.filter(i => new Date(i.created_at) > yesterday);
              closedIssues = issues.filter(i => i.closed_at && new Date(i.closed_at) > yesterday);
            } catch (e) {
              console.log('No issues found');
            }

            // === Decision queue ===
            let decisionIssues = [];
            try {
              const { data } = await github.rest.issues.listForRepo({
                owner, repo, state: 'open', labels: 'status:needs-decision', per_page: 20
              });
              decisionIssues = data.filter(i => !i.pull_request);
            } catch (e) {
              console.log('No decision issues found');
            }

            // === BUILD REPORT ===
            let body = `# CEO Cockpit â€” ${brtDate}\n\n`;

            // Board Summary
            body += `## Board Summary\n\n`;
            body += `| Status | Count |\n|--------|-------|\n`;
            const statusOrder = ['ðŸš€ Roadmap', 'ðŸ§  Backlog', 'ðŸŒ™ Tonight', 'âš™ï¸ Running', 'ðŸ” Review', 'âœ… Done', 'â›” Blocked'];
            for (const s of statusOrder) {
              if (statusCounts[s]) {
                body += `| ${s} | ${statusCounts[s]} |\n`;
              }
            }
            body += `\n`;

            body += `**By Agent:**`;
            const agentEntries = Object.entries(agentCounts).sort((a, b) => b[1] - a[1]);
            for (const [agent, count] of agentEntries) {
              body += ` ${agent} (${count})`;
            }
            body += `\n\n`;

            body += `**By Priority:**`;
            for (const p of ['P0', 'P1', 'P2', 'P3']) {
              if (priorityCounts[p]) body += ` ${p} (${priorityCounts[p]})`;
            }
            body += `\n\n`;

            // Tonight Queue
            body += `## ðŸŒ™ Tonight Queue (${tonightItems.length})\n\n`;
            if (tonightItems.length === 0) {
              body += `_Nenhuma issue programada para tonight_\n\n`;
            } else {
              for (const item of tonightItems) {
                body += `- [#${item.number}](${item.url}) ${item.title} â€” **${item.Agent || 'â€”'}** (${item.Priority || 'â€”'})\n`;
              }
              body += `\n`;
            }

            // Running
            if (runningItems.length > 0) {
              body += `## âš™ï¸ Running (${runningItems.length})\n\n`;
              for (const item of runningItems) {
                body += `- [#${item.number}](${item.url}) ${item.title} â€” **${item.Agent || 'â€”'}**\n`;
              }
              body += `\n`;
            }

            // Review
            if (reviewItems.length > 0) {
              body += `## ðŸ” Review (${reviewItems.length})\n\n`;
              for (const item of reviewItems) {
                body += `- [#${item.number}](${item.url}) ${item.title}\n`;
              }
              body += `\n`;
            }

            // Blockers
            body += `## â›” Blockers (${blockedItems.length})\n\n`;
            if (blockedItems.length === 0) {
              body += `_Nenhum blocker ativo_\n\n`;
            } else {
              for (const item of blockedItems) {
                body += `- [#${item.number}](${item.url}) ${item.title}\n`;
              }
              body += `\n`;
            }

            // Decisions
            body += `## DecisÃµes Pendentes (${decisionIssues.length})\n\n`;
            if (decisionIssues.length === 0) {
              body += `_Nenhuma decisÃ£o pendente_\n\n`;
            } else {
              for (const i of decisionIssues) {
                body += `- [#${i.number}](${i.html_url}) ${i.title}\n`;
              }
              body += `\n`;
            }

            // Issues movidas
            body += `## MovimentaÃ§Ã£o 24h\n\n`;
            body += `**Issues abertas:** ${openedIssues.length} | **Issues fechadas:** ${closedIssues.length}\n\n`;
            if (openedIssues.length > 0) {
              for (const i of openedIssues) {
                body += `- ðŸ†• [#${i.number}](${i.html_url}) ${i.title}\n`;
              }
            }
            if (closedIssues.length > 0) {
              for (const i of closedIssues) {
                body += `- âœ… [#${i.number}](${i.html_url}) ${i.title}\n`;
              }
            }
            if (openedIssues.length === 0 && closedIssues.length === 0) {
              body += `_Nenhuma movimentaÃ§Ã£o_\n`;
            }
            body += `\n`;

            // Commits & PRs
            body += `## Commits & PRs\n\n`;
            body += `**Commits (${commits.length}):**\n`;
            if (commits.length === 0) {
              body += `_Nenhum commit nas Ãºltimas 24h_\n`;
            } else {
              for (const c of commits.slice(0, 10)) {
                const msg = c.commit.message.split('\n')[0];
                const sha = c.sha.substring(0, 7);
                body += `- [\`${sha}\`](${c.html_url}) ${msg}\n`;
              }
              if (commits.length > 10) body += `- _... e mais ${commits.length - 10}_\n`;
            }
            body += `\n`;

            body += `**PRs Merged (${mergedPRs.length}):**\n`;
            if (mergedPRs.length === 0) {
              body += `_Nenhum PR merged_\n`;
            } else {
              for (const pr of mergedPRs) {
                body += `- [#${pr.number}](${pr.html_url}) ${pr.title}\n`;
              }
            }
            body += `\n`;

            // Metrics
            const doneCount = statusCounts['âœ… Done'] || 0;
            const wipCount = (statusCounts['âš™ï¸ Running'] || 0) + (statusCounts['ðŸ” Review'] || 0);
            const totalOpen = projectItems.filter(i => i.state === 'OPEN').length;

            body += `## MÃ©tricas\n\n`;
            body += `| MÃ©trica | Valor |\n|---------|-------|\n`;
            body += `| Done (total) | ${doneCount} |\n`;
            body += `| WIP (Running + Review) | ${wipCount} |\n`;
            body += `| Blocked | ${blockedItems.length} |\n`;
            body += `| Tonight Queue | ${tonightItems.length} |\n`;
            body += `| Total Open | ${totalOpen} |\n`;
            body += `| Closed 24h | ${closedIssues.length} |\n`;
            body += `\n`;

            // CEO Action Items
            body += `## ðŸŽ¯ AÃ§Ãµes Sugeridas para Hoje\n\n`;
            const actions = [];

            if (blockedItems.length > 0) {
              actions.push(`ðŸŸ¡ **Resolver blockers:** ${blockedItems.map(i => `#${i.number}`).join(', ')} precisam de aÃ§Ã£o.`);
            }

            if (tonightItems.length === 0) {
              const backlogReady = projectItems.filter(i =>
                (i.Status || '').includes('Backlog') && (i.Priority === 'P0' || i.Priority === 'P1')
              ).slice(0, 3);
              if (backlogReady.length > 0) {
                actions.push(`ðŸŒ™ **Tonight vazio!** Mover para Tonight: ${backlogReady.map(i => `#${i.number} (${i.Priority})`).join(', ')}`);
              }
            }

            if (reviewItems.length > 0) {
              actions.push(`ðŸ” **Revisar:** ${reviewItems.map(i => `#${i.number}`).join(', ')} aguardam aprovaÃ§Ã£o.`);
            }

            if (decisionIssues.length > 0) {
              actions.push(`ðŸ§  **Decidir:** ${decisionIssues.map(i => `#${i.number} ${i.title}`).join(', ')}`);
            }

            if (actions.length === 0) {
              actions.push(`âœ… **Tudo fluindo bem.** Board saudÃ¡vel, sem aÃ§Ãµes urgentes.`);
            }

            for (const action of actions) {
              body += `${action}\n\n`;
            }

            body += `---\n_CEO Cockpit gerado automaticamente Ã s ${now.toLocaleTimeString('pt-BR', { timeZone: 'America/Sao_Paulo' })} BRT_`;

            // Save report to file for Slack step
            const fs = require('fs');
            fs.writeFileSync('digest-report.md', body);
            core.setOutput('report_date', brtDate);

            // Post to Issue #1
            await github.rest.issues.createComment({
              owner, repo,
              issue_number: 1,
              body
            });
            console.log('Cockpit report posted to issue #1');

      - name: Send digest to Slack
        if: ${{ env.HAS_SLACK == 'true' }}
        env:
          HAS_SLACK: ${{ secrets.SLACK_WEBHOOK_URL != '' }}
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
        run: |
          export TITLE="IOA CEO Cockpit â€” ${{ steps.report.outputs.report_date }}"

          # Split report into chunks respecting Slack's 3000 char section limit
          python3 - <<'PYEOF'
          import json, os

          with open('digest-report.md', 'r') as f:
              report = f.read()

          title = os.environ['TITLE']
          blocks = [
              {"type": "header", "text": {"type": "plain_text", "text": title[:150]}}
          ]

          # Split by ## headings to keep sections together
          sections = report.split('\n## ')
          chunks = []
          current = ''
          for i, section in enumerate(sections):
              piece = section if i == 0 else f'## {section}'
              if len(current) + len(piece) > 2900:
                  if current:
                      chunks.append(current)
                  current = piece[:2900]
              else:
                  current += piece
          if current:
              chunks.append(current)

          for chunk in chunks:
              blocks.append({"type": "section", "text": {"type": "mrkdwn", "text": chunk[:3000]}})
              blocks.append({"type": "divider"})

          payload = json.dumps({"text": title, "blocks": blocks[:50]})
          with open('slack-payload.json', 'w') as f:
              f.write(payload)
          PYEOF

          RESPONSE=$(curl -s -w "\n%{http_code}" -X POST "$SLACK_WEBHOOK_URL" \
            -H 'Content-Type: application/json' \
            -d @slack-payload.json)

          HTTP_CODE=$(echo "$RESPONSE" | tail -1)
          BODY=$(echo "$RESPONSE" | head -1)
          echo "Slack response: $HTTP_CODE â€” $BODY"

          if [ "$BODY" != "ok" ]; then
            echo "::warning::Slack delivery failed: $BODY"
          fi
